package main

import (
	"bufio"
	"flag"
	"fmt"
	frank "github.com/kuking/go-frank"
	"log"
	"os"
	"time"
)

var partSize uint64
var baseFile string
var clientName string
var waitApproach int64
var doHelp bool
var beQuiet bool
var cmd string

func doArgsParsing() bool {
	flag.Uint64Var(&partSize, "ps", 256, "part size in Mb.")
	flag.StringVar(&baseFile, "bs", "persistent-stream", "Base file path")
	flag.StringVar(&clientName, "cn", "client-1", "Client name")
	flag.Int64Var(&waitApproach, "wa", int64(frank.UntilNoMoreData), "Wait approach: -1 until closed, 0 until no more data, N ms wait.")
	flag.BoolVar(&beQuiet, "q", false, "Be quiet, better for performance stats")
	flag.BoolVar(&doHelp, "h", false, "Show usage")
	flag.Parse()
	if doHelp || flag.NArg() != 1 {
		fmt.Printf("Usage of %v: Frank Stream Bus persistent file utility\n\n", os.Args[0])
		flag.PrintDefaults()
		fmt.Print(`

COMMANDS:
  - pub  : publish lines coming from stdin into the persistent stream
  - sub  : subscribe and output to stdout from the persistem stream
 - info : describes the stream state

  Benchmarks:
  - pub_bench : generates 100M events of 100 bytes, outputs performance.
  - sub_bench : consumes a whole stream (i.e. one previously generated by pub_bench) and outputs performance.
 

Examples: 
  $ cat file | franki -ps 1024 -bs test pub
  $ franki -bs test -sn sub-2 sub
`)
		return false
	}

	cmd = os.Args[len(os.Args)-1]
	if cmd != "pub" && cmd != "sub" && cmd != "info" && cmd != "pub_bench" && cmd != "sub_bench" {
		fmt.Println("Unknown command:", cmd)
		return false
	}
	return true
}

func main() {
	if !doArgsParsing() {
		os.Exit(-1)
	}

	if waitApproach > 0 {
		waitApproach *= 1_000_000
	}

	p, err := frank.OpenCreatePersistentStream(baseFile, partSize*1024*1024, frank.ByteArraySerialiser{})
	if err != nil {
		log.Fatal(err)
	}

	if cmd == "sub" {
		s := p.Consume(clientName)
		s.Wait(frank.WaitApproach(waitApproach))
		s.ForEach(func(elem []byte) {
			fmt.Println(string(elem))
		})
	} else if cmd == "pub" {
		s := p.Consume(clientName)
		s.Wait(frank.WaitApproach(waitApproach))
		scanner := bufio.NewScanner(os.Stdin)
		for scanner.Scan() {
			s.Feed(scanner.Bytes())
		}
	} else if cmd == "info" {
		fmt.Println("need to implement")
	} else if cmd == "pub_bench" {
		buf := make([]byte, 0)
		bufS := 100
		for i := 0; i < bufS; i++ {
			buf = append(buf, byte('A'+i%20))
		}
		format := "Total=%4dM IOP; %dMb Bytes. Performance=%2.2fM IOPS; %2.2fMb/s."
		var dur time.Duration
		t0 := time.Now()
		i := 0
		for i = 0; i < 100_000_000; i++ {
			p.Feed(buf)
			if i%1000_000 == 0 {
				dur = time.Now().Sub(t0)
				mops := i / 1000 / 1000
				fmt.Printf(format+"    \r", mops, mops*bufS, float64(mops)/dur.Seconds(), float64(mops*bufS)/dur.Seconds())
			}
		}
		if err = p.CloseFile(); err != nil {
			log.Fatal(err)
		}
		dur = time.Now().Sub(t0)
		mops := i / 1000 / 1000
		fmt.Printf(format+"    \n", mops, mops*bufS, float64(mops)/dur.Seconds(), float64(mops*bufS)/dur.Seconds())
		os.Exit(0)
	} else if cmd == "sub_bench" {
		format := "Total=%4dM IOP; %dMb Bytes. Performance=%2.2fM IOPS; %2.2fMb/s."
		var dur time.Duration
		t0 := time.Now()
		s := p.Consume(clientName)
		bytes := 0
		s.Reset()
		i := 0
		for i = 0; ; i++ {
			v := s.Pull()
			if v.IsPresent() {
				bytes += len(v.Get().([]byte))
			} else {
				break
			}
			if i%1000_000 == 0 {
				dur = time.Now().Sub(t0)
				mops := i / 1000 / 1000
				megas := bytes / 1000 / 1000
				fmt.Printf(format+"    \r", mops, megas, float64(mops)/dur.Seconds(), float64(megas)/dur.Seconds())
			}
		}
		dur = time.Now().Sub(t0)
		mops := i / 1000 / 1000
		megas := bytes / 1000 / 1000
		fmt.Printf(format+"    \n", mops, megas, float64(mops)/dur.Seconds(), float64(megas)/dur.Seconds())

	}

	if err := p.CloseFile(); err != nil {
		log.Fatal(err)
	}

}
