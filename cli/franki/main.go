package main

import (
	"bufio"
	"flag"
	"fmt"
	frank "github.com/kuking/go-frank"
	"log"
	"os"
	"time"
)

var partSize uint64
var miop uint
var eventSize uint
var baseFile string
var clientName string
var waitApproach int64
var doHelp bool
var beQuiet bool
var cmd string

func doArgsParsing() bool {
	flag.Uint64Var(&partSize, "ps", 256, "part size in Mb.")
	flag.UintVar(&miop, "miop", 100, "mega-iop to publish (for pub_bench).")
	flag.UintVar(&eventSize, "evs", 100, "event-size in bytes (for pub_bench)")
	flag.StringVar(&baseFile, "bs", "persistent-stream", "Base file path")
	flag.StringVar(&clientName, "cn", "client-1", "Client name")
	flag.Int64Var(&waitApproach, "wa", int64(frank.UntilNoMoreData), "Wait approach: -1 until closed, 0 until no more data, N ms wait.")
	flag.BoolVar(&beQuiet, "q", false, "Be quiet, better for performance stats")
	flag.BoolVar(&doHelp, "h", false, "Show usage")
	flag.Parse()
	if doHelp || flag.NArg() != 1 {
		fmt.Printf("Usage of %v: Frank Stream Bus persistent file utility\n\n", os.Args[0])
		flag.PrintDefaults()
		fmt.Print(`

COMMANDS:
  - pub  : publish lines coming from stdin into the persistent stream
  - sub  : subscribe and output to stdout from the persistem stream
 - info : describes the stream state

  Benchmarks:
  - pub_bench : generates 100M events of 100 bytes, outputs performance.
  - sub_bench : consumes a whole stream (i.e. one previously generated by pub_bench) and outputs performance.
 

Examples: 
  $ cat file | franki -ps 1024 -bs test pub
  $ franki -bs test -sn sub-2 sub
`)
		return false
	}

	cmd = os.Args[len(os.Args)-1]
	if cmd != "pub" && cmd != "sub" && cmd != "info" && cmd != "pub_bench" && cmd != "sub_bench" {
		fmt.Println("Unknown command:", cmd)
		return false
	}
	return true
}

func logStats(t0 *time.Time, iop uint64, totalIop uint64, bytes uint64, last bool) {
	if iop%1_000_000 == 0 || last {
		dur := time.Now().Sub(*t0)
		mops := iop / 1_000_000
		mb := bytes / 1_000_000
		completed := float64(iop*100) / float64(totalIop)
		ch := "\r"
		if last {
			ch = "\n"
		}
		fmt.Printf("Totals=%dM IOP; %dMB; Perfs=%2.2fM IOPS; %2.2fMB/s; avg %v/iop; [%0.0f%%]     %v",
			mops, mb, float64(mops)/dur.Seconds(), float64(mb)/dur.Seconds(),
			time.Duration(dur.Nanoseconds()/int64(iop+1)), completed, ch)
	}
}

func main() {
	if !doArgsParsing() {
		os.Exit(-1)
	}

	if waitApproach > 0 {
		waitApproach *= 1_000_000
	}

	p, err := frank.OpenCreatePersistentStream(baseFile, partSize*1024*1024, frank.ByteArraySerialiser{})
	if err != nil {
		log.Fatal(err)
	}

	if cmd == "sub" {
		s := p.Consume(clientName)
		s.Wait(frank.WaitApproach(waitApproach))
		s.ForEach(func(elem []byte) {
			fmt.Println(string(elem))
		})
	} else if cmd == "pub" {
		s := p.Consume(clientName)
		s.Wait(frank.WaitApproach(waitApproach))
		scanner := bufio.NewScanner(os.Stdin)
		for scanner.Scan() {
			s.Feed(scanner.Bytes())
		}
	} else if cmd == "info" {
		fmt.Println("need to implement")
	} else if cmd == "pub_bench" {
		buf := make([]byte, 0)
		bufS := int(eventSize)
		for i := 0; i < bufS; i++ {
			buf = append(buf, byte('A'+i%20))
		}
		t0 := time.Now()
		i := 0
		for i = 0; i < int(miop)*1_000_000; i++ {
			p.Feed(buf)
			logStats(&t0, uint64(i), uint64(miop*1_000_000), uint64(i*bufS), false)
		}
		if err = p.CloseFile(); err != nil {
			log.Fatal(err)
		}
		logStats(&t0, uint64(i), uint64(miop*1_000_000), uint64(i*bufS), true)
		os.Exit(0)
	} else if cmd == "sub_bench" {
		t0 := time.Now()
		s := p.Consume(clientName)
		bytes := 0
		s.Reset()
		i := 0
		for i = 0; ; i++ {
			v := s.Pull()
			if v.IsPresent() {
				bytes += len(v.Get().([]byte))
			} else {
				break
			}
			logStats(&t0, uint64(i), 0, uint64(bytes), false)
		}
		logStats(&t0, uint64(i), 0, uint64(bytes), true)
	}

	if err := p.CloseFile(); err != nil {
		log.Fatal(err)
	}

}
